The aim the object model is to simplify the data encapsulation and minimize the weight of the data that the objects carry around at run time whie executing.  The domain objects will map directly to the artifacts in the process, resumes, resumereview, etc.  To represent the user, "user" object is the base class where all of the common elements like names, addresses are held.  Once we specialize the user object into specific user type like "candidate" we hold the relevant objects like resume in the object.  Since the object model performance is effected by the persistence strategy, we will lazy load those objects at first use.  To allow flexibility in the persistence strategy, the DAO like layer is used.

The objects are persisted onto Couchdb on the back end.  Each model will have a corresponding DAO object that does the CRUD.  The object will always have a full persisted sub objects when it is initialized and come into existence.  That simplify the save function for the main object like resume, which has addresses as sub objects etc.  When we save resume we required that addresses and the like are already save when they were passed into resume.  When the resume is saved, only the ids of those sub objects are really saved.  Hence that serves as the pointer to sub objects.  Any updates to the sub object will reflect in the next resume retrieval as well since the sub objects are freshly retrieved every time we bring resume into existence.  However, we do persistence a little differently with job-application since we need the information to be frozen at the point of jop-application creation.  Which means we saved the data of the sub object itself into job-application object, not just pointer to the sub objects.  And that requires the make-{object type}-complete methods to bring back the full object for job-application.