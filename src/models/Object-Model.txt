The aim the object model is to simplify the data encapsulation and minimize the weight of the data that the objects carry around at run time whie executing.  The domain objects will map directly to the artifacts in the process, resumes, resumereview, etc.  To represent the user, "user" object is the base class where all of the common elements like names, addresses are held.  Once we specialize the user object into specific user type like "candidate" we hold the relevant objects like resume in the object.  Since the object model performance is effected by the persistence strategy, we will lazy load those objects at first use.  To allow flexibility in the persistence strategy, the DAO like layer is used.

The objects are persisted onto Couchdb on the back end.  Each model will have a corresponding DAO object that does the CRUD.  The object will always have a full persisted sub objects when it is initialized and come into existence.  That simplify the save function for the main object like resume, which has addresses as sub objects etc.  When we save resume we required that addresses and the like are already save when they were passed into resume.  When the resume is saved, only the ids of those sub objects are really saved.  Hence that serves as the pointer to sub objects.  Any updates to the sub object will reflect in the next resume retrieval as well since the sub objects are freshly retrieved every time we bring resume into existence.  However, we do persistence a little differently with job-application since we need the information to be frozen at the point of jop-application creation.  Which means we saved the data of the sub object itself into job-application object, not just pointer to the sub objects.  And that requires the make-{object type}-complete methods to bring back the full object for job-application.

In the case of relationship between the main and sub object, in general the main object will contain the full sub object or objects in its slots while the the sub object will hold the id reference to the main object.  This is to avoid the cyclic references between the main and sub objects.  That plays a role in avoiding the infinite loop of marshaling and unmarshaling the objects which is dicussed below.

The machanic of persistence to Couchdb is to send string of JSON objects over the REST api to perform CRUD functions.  The abstraction is done using cl-couch.  The values of the objects are marshalled into JSON format by the function valu-list-of {object instance} 'as-{list type, alist or plist} &optional '{with or without} '{list of things to include or exclude} '{sub-object-as-id}.  For unmarshalling, we have the make-{object name} functions to bring back and instantiate the object.  Every persisted object to Couchdb has rev number.  So we use that to test if the object has already been persisted.  Also, the id are generated with the combination of parent object + object type and unique 10 digit numbers.  So to test equality for the objects we just compare the id of the objects in comparison.  For job-application, we concat job-application + job-posting id + resume id, since it has to be unique and there can only be one application for the resume.   